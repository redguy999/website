<html>
	<head>
		<title>basic grid tester</title>
		<style>
			body{
				margin:0;
				width:100vw;
				height:100vh;
				overflow-x: hidden;
				overflow-y: hidden;
			}
			#movementGrid{
				margin-top:0;
				margin:auto;
				display:grid;
				/*grid-template-columns: auto auto auto auto auto; moved to JS*/
				align-content: center;
				max-width:99vw;
				width:70vw;
				max-height:98vh;
				height: 80vh;
				border:black 1px double;

			}
			#movementGrid>div{
				margin:auto;
				width:90%;
				max-width:90%;
				height:90%;
				max-height:90%;
				border:1px solid black;
				display: flex;
				justify-content: center;
				align-items: center;
			}
			#inventBorder{
				position: absolute; left: 85vw; top: 0%;
				width:14vw;
				height:40vh;
				border: 1px solid black;
				overflow-x: hidden;
  				overflow-y: scroll;
				text-align:center;
			}
			#equipmentArea{
				position: absolute; left: 85vw; top: 40vh;
				width:14vw;
				height:40vh;
				border: 1px solid black;
				overflow-x: hidden;
  				overflow-y: scroll;
				text-align:center;
			}
			.E:hover{
				font-weight: bold;
				color:blue;
			}
			.U:hover{
				font-weight: bold;
				color:Orange;
			}
			#statDisplay{
				position: absolute; right: 85vw; top: 0;
				width:14vw;
				height:40vh;
				border: 1px solid black;
				text-align: center;
				overflow-x: hidden;
  				overflow-y: scroll;
			}
			#infoDisplay{
				position: absolute; right: 85vw; top: 40vh;
				width:14vw;
				height:40vh;
				border: 1px solid black;
				text-align: center;
				overflow-x: hidden;
  				overflow-y: scroll;
			}
		</style>
	</head>
	<!--due to how the Grid tiles are styled, changing the size of the grid div will not break the tiles.-->
	<body onload="startGame()" onkeydown="keyPress()">
		<div id="statDisplay">
			<h1>Stats:</h1>
			HP: <span id="health"></span>/<span id="Mhealth"></span><br>
			attack: <span id="attack"></span><br>
			defense: <span id="defense"></span>
			<!--not adding special here since we still haven't added that.-->
		</div>
		<div id="InfoDisplay">
			<h1>Info:</h1>
			Floor: <span id="levelDis"></span>
		</div>
		<div id="movementGrid">

		</div>
		<div id="inventBorder">
			<h1>Items:</h1>
			<p id="inventDisplay">
			
			</p>
		</div>
		<div id="equipmentArea">
			<!--keep it like this, when i tried to change it to just the div it broke and i couldn't fix it. had to rollback to a working version.-->
			<h1>Equipment:</h1>
			<p id="equipDisplay">

			</p>
		</div>
	</body>
	<script src="rogueFunctions.js"></script><script src="equipConstructors.js"></script>
	<script>
		/*TODO: make enemy drops, rework attacking, add console to bottom of screen, (optional: rework how locations are read and stored.)
		*/
		//items are gonna need overhauled at some point.
		var entLocs = []//each entry will be a corrdinate string. Entries will be where the location of all the enemies and items are.  
		const AllItems = ["gold coin","sword","shield","spear","potion"];//array contaning the name of every (findable) item possible.
		const equipable = ["sword","shield","spear"];//array containing the name of every item that is equipable.
		const useable = ["potion"];//array containing the name of every item that is usable
		const inventory = {
			
		}
		const equipment = {//might need to overhaul how items work before i can do this.
			mainHand:{
				name:"empty"
			},
			offHand:{
				name:"empty"
			},
			equipEquipment:function(equipment){
				/*debugger*/;
				let temp=itemStats[equipment];
				switch (temp["slot"]) {
					case "mainHand":
						if(this.mainHand.name!="empty"){
							return;//something is already equiped
						}
						this.mainHand=itemStats.getStats(equipment);
						break;
					case "offHand":
						if(this.offHand.name!="empty"){
							return;//something is already equiped
						}
						this.offHand=itemStats.getStats(equipment);
						break;
					case "2Hands":
						if(this.offHand.name!="empty"||this.offHand.name!="empty"){
							return;//something is already equiped
						}
						this.mainHand=itemStats.getStats(equipment);
						this.offHand["name"]="FULL"
						break;
					default:
						console.error("invalid slot setting.")
						break;
				}
				inventory[equipment]-=1;
				displayInvent();
				displayEquipment();
				player.updateStats();
			},
		};
		var equipDisplay=document.getElementById("equipDisplay");
		function displayEquipment(){//this needs overhauled if we want to add more slots. for in should help.
			//this could be turned into a nested for in loops, but a dictonary object would be required
			equipDisplay.innerHTML="";//need to clear it.
			equipDisplay.innerHTML+="Main hand item:<br>";//might change this, but this will work for now.
			//debugger;
			for(x in equipment.mainHand){
				if(equipment["mainHand"].name=="empty"){
					equipDisplay.innerHTML+="empty";
					break;//we can just early exit since there shouldn't be anything else to read.
				}
				equipDisplay.innerHTML+=x+" : "+equipment.mainHand[x]+"<br>";
			}
			if(equipment["mainHand"].name!="empty"){
				equipDisplay.innerHTML+="<span span class='E' onClick='unequip(\"mainHand\")'>Unequip?"
			}
			equipDisplay.innerHTML+="<br>Off hand item:<br>";
			for(x in equipment.offHand){
				if(equipment["offHand"].name=="FULL"){//this only accords if an item is equiped in 2Hands.
					equipDisplay.innerHTML+="("+equipment.mainHand.name+")<br>";//might need to overhaul how 2 slot equipment works if we want to change this to work with different slots.
					break;//early exit since we don't need to read it.
				} else if(equipment.offHand.name=="empty"){
					equipDisplay.innerHTML+="empty";
					break;//we can just early exit since there shouldn't be anything else to read.
				}
				equipDisplay.innerHTML+=x+" : "+equipment.offHand[x]+"<br>";
			} 
			if(equipment["offHand"].name!="empty"&&equipment["offHand"].name!="FULL"){//i think this works.
				equipDisplay.innerHTML+="<span span class='E' onClick='unequip(\"offHand\")'>Unequip?"
			}
		}
		function unequip(slot){
			let temp=equipment[slot].name;
			if(itemStats[temp].slot=="2Hands"){
				for(x in equipment.offHand){
					delete equipment.offHand[x]
				}
				for(x in equipment.mainHand){
					delete equipment.mainHand[x]
				}
				equipment.offHand.name="empty";
				equipment.mainHand.name="empty";
			} else {
				for(x in equipment[slot]){
					delete equipment[slot][x];
				}
				equipment[slot].name="empty";
			}
			console.log(temp);
			if(typeof(inventory[temp])=="undefined"){
				inventory[temp]=1;
			}else{
				inventory[temp]+=1;
			}
			displayInvent();
			displayEquipment();
			player.updateStats();
		}
		class treasure{
			constructor(location,contents,amount,locked){
				this.location = location;
				this.contents = contents;//string or an object, figure that out at some point.
				this.amount = amount;
				this.locked = locked;//string or boolean, depending on if we want specific keys to open specific chests.
				this.getItem = function(){
					if(this.amount==1){
						alert("you found a "+this.contents+".")
					}else{
						alert("you found some "+this.contents+"s.");//change this to log at the bottom console
					}
					setBGColor(this.location,"white");
					entLocs.splice(entLocs.indexOf(this.location),1);
					this.location = null;
					addToInventory(this.contents,this.amount);
				}
			}
		}
		class enemy{
			constructor(name,Mhealth,attack,defense,special=null){
				this.name = name;//string
				this.location = location;//string
				this.Mhealth = Mhealth;//number
				this.health = Mhealth; //health starts equal to max health.
				this.attack = attack; //number
				this.defense = defense; //number
				this.special = special;//no clue what this would be. maybe a map. its optional anyway.
				this.hurt = function(damg){
					let temp = 0;
					if(damg>0){//if damage is negative, ignore defense, since it is likely healing.
					temp = Math.ceil(damg-(this.defense/2))//current defense calucation formula, will likely change it.
					if(temp<=0){
						console.log("The "+this.name+"'s armor completely protects them from harm!")
						this.attack();//skip to attack
						return;//nothing else to do.
					}
					} else{
						temp = damg
					}
					//probably some check for special attributes, oh and also defense
					//if the enemy doesn't have "health" which can be determined by checking max health, call a special function.
					this.health-=temp;
					console.log("the "+this.name+" has "+this.health+"HP remaining.");
					if(this.health>this.Mhealth){//this function can be used for healing too.
						this.health=this.Mhealth;
					} else if(this.health<=0){
						this.dead()
						return;//need to early return because otherwise attack runs.
					}
					this.fight();
				}
				this.dead = function(){
					alert("you have defeated the "+this.name+".");
					setBGColor(this.location,"white");
					entLocs.splice(entLocs.indexOf(this.location),1);
					this.location = null;
				}
				this.fight = function(){//might make it able to attack anyone.
					if(this.attack==0){
						return;//early exit in case the enemy can't attack.
					}
					player.hurtPlayer(this.attack);
				}
			}
		}
			const player = {//could probably move the location variable here but that would be kinda annoying.
				attack:1,//default values, attack should never go below 1 while alive.
				defense:0,//TODO: make this actually do stuff.
				Mhealth:100,
				health:100,
				special:null,//null means none
				hurtPlayer:function(damg){//this could be its own function but its easier to call the variables here.
					//defense and special attribute checks go here.
					debugger;
					let temp = 0;
					if(damg>0){
					temp = Math.ceil(damg-(this.defense/2))//current defense calucation formula, will likely change it.
					if(temp<=0){
						console.log("Your armor completely protects you from harm!")
						updateHealth()
						return;//no damage to deal, skip to end.
					}
					} else{//if damage is negative, ignore defense.
						temp = damg
					}
					this.health-=temp;
					if(this.health>this.Mhealth){//this function can be used for healing, so we need to check for this edge case.
						this.health=this.Mhealth;
					} else if(this.health<=0){
						alert("oh no we're dead.");
						//insert calling game over function here.
						return;
					}
					updateHealth()
			},
			updateStats:function(){
				this.attack = 1;
				this.defense = 0;
				this.Mhealth = 100;//default values
				this.special = null;//we have no way of editing this currently but i'll leave it here.
				for (x in equipment){
					for(y in equipment[x]){//reads every property of every slot, might also try to read the functions but that is easy to stop.
						if(equipment[x][y]=="empty"){
							continue;
						}
						this[y]+=equipment[x][y];
					}
				}
				for(x in player){
					if(typeof(x)=="undefined"){
						console.error("stat became invalid, priting stat logs:");
						console.log(this.attack);
						console.log(this.defense);
						console.log(this.Mhealth);
						console.log("reseting values to default:")
						this.attack = 1;
						this.defense = 0;
						this.Mhealth = 100;
						this.special = null;
					}
				}
				if(this.health>this.Mhealth){
					this.health=this.Mhealth;
				} 
				updateStatistics()
			}
		}
		//classes above, objects and functions below:
		function mkOtherStuff(){
			placeItems();
			displayEquipment();
			updateStatistics();
			updateInfo();
		}
		function updateInfo(){
			document.getElementById("levelDis").innerHTML = level;
		}
		function placeItems(){//might move this to the class of item
			entLocs = [];
			let RNG = Math.floor(Math.random()*3);
			for(i=0;i<RNG;i++){//should set all the items.
				iList[i]["contents"] = GIFL();
				iList[i]["amount"] = Math.floor(Math.random()*3+1);//need to rework so you can get a lot of coins and not a lot of weapons.
				let temp = getCorrdInGrid();
				while(temp==startPoint||temp==exitPoint||walls.indexOf(temp)!=-1||entLocs.indexOf(temp)!=-1){
					temp  = getCorrdInGrid();
				}
				iList[i]["location"] = temp;
				entLocs.push(temp);
				setBGColor(temp,"gold");
			}
			placeEnemies();
		}
		function placeEnemies(){
			let RNG = Math.floor(Math.random()*6);//0-5 if random*6
			//might rework the RNG formulas so that it becomes harder as you get to lower floors.
			debugger;
			for(let i=0;i<RNG;i++){
				let color;
				if(Math.floor(Math.random()*2)==0){//TODO: fix glitch that causes Goblins to look like armored goblins and vice versa.
					eList.push(new enemy("Goblin",10,1,0));
					color="orange"
				} else {
					eList.push(new enemy("Armored goblin",15,3,3));
					color="grey"
				}
				eList[i]["health"]=eList[i]["Mhealth"];//full heal.
				let temp = getCorrdInGrid();
				while(temp==startPoint||temp==exitPoint||walls.indexOf(temp)!=-1||entLocs.indexOf(temp)!=-1){//goblins can place themselves on the exit tile, which should be impossible
					temp  = getCorrdInGrid();
				}
				eList[i]["location"]=temp;
				// document.getElementById(eList[i]["location"]).innerHTML = eList[i]["name"]
				entLocs.push(temp);
				setBGColor(temp,color);
			}
		}
		function GIFL(){//get item from list
			return AllItems[Math.floor(Math.random()*(AllItems.length))];//this won't need changed if the length of AllItems changes.
		}
		function collectOrCombat(){//too lazy to change the name even if have of it no longer works.
			for(let i=0;i<iList.length;i++){
				if(iList[i]["location"]==playerLoc){
					iList[i].getItem();
				}
			}
		}
		//make the items and enemies be in an array, this will allow for loop calling, which is must easier to expand.
		function addToInventory(item,amount){//self explainitory
			if(typeof(inventory[item])=="undefined"){
				inventory[item]=amount;
			}else{
			inventory[item]+=amount;
			}
			try{
				displayInvent()
			} catch {

			}
			console.log(inventory);
		}
		function equipItem(item){
			try{//incase equipConstructors gets removed.
				if((typeof(itemStats[item])=="undefined")||(typeof(itemStats[item])!="object")){//second check would be false for arrays, since they are objects.
					console.error("attempted to equip a nonexistant/unequipable item.");
					console.log("invalid item entry:")
					console.log(item)
					return;//early exit since rest of code would break otherwise.
				}
				console.log(itemStats[item]);
				equipment.equipEquipment(item);
			} catch {
				console.error("couldn't find equipConstructors.js");
				return;
			}
		}
		function useItem(item){
			try{
				if((typeof(itemStats[item])=="undefined")||(typeof(itemStats[item])!="object")){
					console.error("attempted to use a nonexistant/unuseable item.");
					console.log("invalid item entry:")
					console.log(item)
				}
				inventory[item]-=1;
				itemStats.useItem(item);
				displayInvent();
			} catch {
				console.error("couldn't find equipConstructors.js");
				return;
			}
		}
		//new enemy("Goblin",10,1,0)
		//new enemy("Armored goblin",15,5,3)
		const eList = [];
		//console.log(eList[1]["health"])//displays the health of the second enemy in the array.
		//eList objects being constructed inside the array is only temporary, that will be moved.
		const iList = [new treasure(null),new treasure(null),new treasure(null)];
		const inDis= document.getElementById("inventDisplay");
    	function displayInvent(){
			///*debugger*/;
			inDis.innerHTML = "";
    		for (x in inventory){
				if(inventory[x]<=0){
					console.log(x+" has been removed.")
					delete inventory[x];
					continue;
				}
				if(inventory[x]!=1){
					if(equipable.indexOf(x)!=-1){
						inDis.innerHTML += "<span class='E' onClick='equipItem(\""+x+"\")'>"+inventory[x] + " " + x+"s</span><br>";
					} else if(useable.indexOf(x)!=-1){
						inDis.innerHTML += "<span class='U' onClick='useItem(\""+x+"\")'>"+inventory[x] + " " + x+"s</span><br>";
					} else {
						inDis.innerHTML += inventory[x] + " " + x+"s<br>";
					}
				}else{
					if(equipable.indexOf(x)!=-1){
						inDis.innerHTML += "<span class='E' onClick='equipItem(\""+x+"\")'>"+inventory[x] + " " + x+"</span><br>";
					} else if(useable.indexOf(x)!=-1){
						inDis.innerHTML += "<span class='U' onClick='useItem(\""+x+"\")'>"+inventory[x] + " " + x+"</span><br>";
					} else {
						inDis.innerHTML += inventory[x] + " " + x+"<br>";
					}
				}
      		}
    	}
		function forceAddItem(item,amount){//for admin use only, currently
			if(typeof(inventory[item])=="undefined"){
				inventory[item]=amount;
			}else{
				inventory[item]+=amount;
			}
			displayInvent();
		}
		const healthDis = document.getElementById("health")
		const MhealthDis = document.getElementById("Mhealth")
		const attackDis = document.getElementById("attack")
		const defenseDis = document.getElementById("defense")
		function updateStatistics(){//fixes the stat display, should be called when an item is equiped
			updateHealth();
			attackDis.innerHTML = player.attack;
			defenseDis.innerHTML = player.defense;
		}
		function updateHealth(){//we only need to update this when the player is hurt
			healthDis.innerHTML = player.health;
			MhealthDis.innerHTML = player.Mhealth;
		}
	</script>
</html>
